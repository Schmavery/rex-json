
    
<!doctype html>
<meta charset=utf8>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel=stylesheet href='./styles.css'>
<script defer src='./script.js'></script>
<title>Home</title>
<body>
<script>window.relativeToRoot="."</script>
<div id='error-message'>
  ⚠️ Oops! This page doesn't appear to define a <span>type</span> called <code>_</code>.
</div>

    
    <div class='container'>
    
    <div class='sidebar-wrapper'>
    <div class='sidebar-expander'>Show navigation</div>
    <div class='sidebar'>
      <a href="./search.html" style="display: block; padding: 0 8px;">Search</a>
      <div class='docs-listing'><a href="./index.html">Home</a></div>
      <div class='table-of-contents'>
      <div class='toc-header'>Page Contents</div>
      <a href="#rex-json" class='level-1 header'>Rex Json</a>
<a href="#installation" class='level-2 header'>Installation</a>
<a href="#usage-" class='level-2 header'>Usage:</a>
      </div>
      <div class='project-listing'><div class='project-title'>Package modules</div><a href="./api/Json.html">Json</a>
<a href="./api/BigList.html">BigList</a>
<a href="./api/Test.html">Test</a>
<a href="./api/TestLib.html">TestLib</a></div>
    </div>
    </div>
  
    <div class='main'>
    <a href="https://github.com/jaredly/rex-json/blob/master/docs/./index.md" class="edit-link">Edit</a>
    <a href="#rex-json" id="rex-json"><h1>Rex Json</h1></a>

<blockquote><p>A simple cross-target JSON library for Reason/OCaml</p>
</blockquote>

<p>Works with both native and js targets (compiled with bsb-native).</p>
<p>Why would you want this library?</p>
<ul><li>you want minimal dependencies</li><li>you want forgiving json parsing (comments, trailing commas allowed)</li><li>you&#39;re fine with &quot;good enough&quot; performance</li></ul>

<a href="#installation" id="installation"><h2>Installation</h2></a><p>Add <code>rex-json</code> to your <code>package.json</code> and your <code>bsconfig.json</code>.</p>
<a href="#usage-" id="usage-"><h2>Usage:</h2></a><pre class='code'><code>let <span class='pattern-ident' data-type="string">data</span> = <span class='string' data-type="string">{|
{
  &quot;some&quot;: &quot;json&quot;, // with a comment!
  &quot;more&quot;: [1,3,],
  /* also
  multi-line comment */
  &quot;this&quot;: {
    &quot;object&quot;: {
      &quot;is&quot;: {
        &quot;really&quot;: &quot;nested&quot;
      }
    }
  },
  &quot;nested&quot;: [{
    &quot;and&quot;: [1,2,{&quot;stuff&quot;: 5}]
  }], // trailing commas!
}
|}</span>;
let <span class='pattern-ident' data-type="Json.t">json</span> = <span class='ident' data-type="string => Json.t">Json.parse</span>(<span class='ident' data-type="string">data</span>);
let <span class='pattern-ident' data-type="option(Json.t)">simple</span> = <span class='ident' data-type="(string, Json.t) => option(Json.t)">Json.get</span>(<span class='string' data-type="string">&quot;some&quot;</span>, <span class='ident' data-type="Json.t">json</span>); /* == Some(String(&quot;json&quot;)) */

open Json.Infix;

let <span class='pattern-ident' data-type="option(float)">stuff</span> = <span class='ident' data-type="Json.t">json</span>
  <span class='operator' data-type="(Json.t, Json.t => option(Json.t)) => option(Json.t)">|&gt;</span> <span class='ident' data-type="(string, Json.t) => option(Json.t)">Json.get</span>(<span class='string' data-type="string">&quot;nested&quot;</span>)
  <span class='operator' data-type="(option(Json.t), Json.t => option(Json.t)) => option(Json.t)">|?&gt;</span> <span class='ident' data-type="(int, Json.t) => option(Json.t)">Json.nth</span>(<span class='int' data-type="int">0</span>)
  <span class='operator' data-type="(option(Json.t), Json.t => option(Json.t)) => option(Json.t)">|?&gt;</span> <span class='ident' data-type="(string, Json.t) => option(Json.t)">Json.get</span>(<span class='string' data-type="string">&quot;and&quot;</span>)
  <span class='operator' data-type="(option(Json.t), Json.t => option(Json.t)) => option(Json.t)">|?&gt;</span> <span class='ident' data-type="(int, Json.t) => option(Json.t)">Json.nth</span>(<span class='int' data-type="int">2</span>)
  <span class='operator' data-type="(option(Json.t), Json.t => option(Json.t)) => option(Json.t)">|?&gt;</span> <span class='ident' data-type="(string, Json.t) => option(Json.t)">Json.get</span>(<span class='string' data-type="string">&quot;stuff&quot;</span>)
  <span class='operator' data-type="(option(Json.t), Json.t => option(float)) => option(float)">|?&gt;</span> <span class='ident' data-type="Json.t => option(float)">Json.number</span>; /* == Some(5.) */

/** Using a json path for nested objects */
let <span class='pattern-ident' data-type="option(Json.t)">nestedObj</span> = <span class='ident' data-type="Json.t">json</span> <span class='operator' data-type="(Json.t, Json.t => option(Json.t)) => option(Json.t)">|&gt;</span> <span class='ident' data-type="(string, Json.t) => option(Json.t)">Json.getPath</span>(<span class='string' data-type="string">&quot;this.object.is.really&quot;</span>); /* Some(String(&quot;nested&quot;)) */

let <span class='pattern-ident' data-type="string">str</span> = <span class='ident' data-type="Json.t => string">Json.stringify</span>(<span class='ident' data-type="Json.t">json</span>); /* back to a string */</code></pre>
    </div>
    <div class='right-blank'></div>
    </div>
  